--
-- PostgreSQL database dump
--

-- Dumped from database version 9.5.3
-- Dumped by pg_dump version 9.5.3

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

SET search_path = public, pg_catalog;

--
-- Data for Name: Applications; Type: TABLE DATA; Schema: public; Owner: cloudify
--

COPY "Applications" (id, name, status, "isPrivate", extras, "createdAt", "updatedAt") FROM stdin;
\.


--
-- Name: Applications_id_seq; Type: SEQUENCE SET; Schema: public; Owner: cloudify
--

SELECT pg_catalog.setval('"Applications_id_seq"', 1, false);


--
-- Data for Name: BlueprintAdditions; Type: TABLE DATA; Schema: public; Owner: cloudify
--

COPY "BlueprintAdditions" (id, "blueprintId", image, "imageUrl", "createdAt", "updatedAt") FROM stdin;
1	Kubernetes-AWS-EKS	\N	/console/external/content?url=https%3A%2F%2Frepository.cloudifysource.org%2Fcloudify%2Fblueprints%2F5.1%2Fimages%2Fk8s.png	2020-09-30 15:15:32.237+00	2020-09-30 15:15:32.27+00
\.


--
-- Name: BlueprintAdditions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: cloudify
--

SELECT pg_catalog.setval('"BlueprintAdditions_id_seq"', 1, true);


--
-- Data for Name: BlueprintUserData; Type: TABLE DATA; Schema: public; Owner: cloudify
--

COPY "BlueprintUserData" (id, "blueprintId", username, layout, "createdAt", "updatedAt") FROM stdin;
1	blueprints_test_empty	admin	{"nodes":[{"name":"vm","width":210,"height":230,"x":40,"y":40,"uiType":"Compute","type":"cloudify.nodes.Compute"}],"connectors":[],"groups":[],"scaleInfo":{"scale":1.1551724137931034,"offset":[0,40.006332558089284]}}	2020-10-23 12:49:44.615+00	2020-10-23 13:26:50.973+00
\.


--
-- Name: BlueprintUserData_id_seq; Type: SEQUENCE SET; Schema: public; Owner: cloudify
--

SELECT pg_catalog.setval('"BlueprintUserData_id_seq"', 1, true);


--
-- Data for Name: ClientConfigs; Type: TABLE DATA; Schema: public; Owner: cloudify
--

COPY "ClientConfigs" (id, "managerIp", config, "createdAt", "updatedAt") FROM stdin;
1	127.0.0.1	{"canUserEdit":true}	2020-09-23 10:31:28.814+00	2020-09-23 10:31:28.814+00
\.


--
-- Name: ClientConfigs_id_seq; Type: SEQUENCE SET; Schema: public; Owner: cloudify
--

SELECT pg_catalog.setval('"ClientConfigs_id_seq"', 1, true);


--
-- Data for Name: UserApps; Type: TABLE DATA; Schema: public; Owner: cloudify
--

COPY "UserApps" (id, "managerIp", username, "appDataVersion", mode, "appData", "createdAt", "updatedAt", tenant) FROM stdin;
1	127.0.0.1	admin	4	main	{"pages":[{"id":"dashboard","name":"Dashboard","description":"","tabs":[],"widgets":[{"id":"73b785c0-0eba-4e57-8cff-fd0df9a4fabe","name":"Number of blueprints","x":0,"y":0,"width":2,"height":8,"definition":"blueprintNum","configuration":{"pollingTime":10,"page":"local_blueprints"},"drillDownPages":{}},{"id":"1f199bf5-033c-444e-a9b0-d979899ad85f","name":"Number of deployments","x":2,"y":0,"width":2,"height":8,"definition":"deploymentNum","configuration":{"pollingTime":10,"page":"deployments"},"drillDownPages":{}},{"id":"65d6cfef-1561-4393-99c0-c5ffa8a55667","name":"Number of plugins","x":4,"y":0,"width":2,"height":8,"definition":"pluginsNum","configuration":{"pollingTime":30,"page":"system_resources"},"drillDownPages":{}},{"id":"4b59ab5b-dc31-45b1-b13e-abfa7e7ca102","name":"Number of compute nodes","x":6,"y":0,"width":2,"height":8,"definition":"nodesComputeNum","configuration":{"pollingTime":30},"drillDownPages":{}},{"id":"6cf6d5e1-5524-4e7e-b63c-50818739dd55","name":"Number of running executions","x":8,"y":0,"width":2,"height":8,"definition":"executionNum","configuration":{"pollingTime":10},"drillDownPages":{}},{"id":"fbdbe844-bfea-4967-a538-1cfaf485e014","name":"Blueprint Upload Button","x":0,"y":8,"width":2,"height":3,"definition":"blueprintUploadButton","configuration":{},"drillDownPages":{}},{"id":"38b4ff3a-f22f-4c53-91cc-12d5851c3fab","name":"Deployment Button","x":2,"y":8,"width":2,"height":3,"definition":"deploymentButton","configuration":{},"drillDownPages":{}},{"id":"4a67d456-c068-40cb-9bc1-4dcca31e49bd","name":"Plugin Upload Button","x":4,"y":8,"width":2,"height":3,"definition":"pluginUploadButton","configuration":{},"drillDownPages":{}},{"id":"07ecaea0-d97a-4109-8ab6-4a320a9c91c1","name":"Filter","x":0,"y":10,"width":12,"height":3,"definition":"filter","configuration":{"pollingTime":10,"filterByBlueprints":true,"filterByDeployments":true,"filterByExecutions":false,"filterByNodes":false,"filterByNodeInstances":false,"filterByExecutionsStatus":true,"filterBySiteName":false,"allowMultipleSelection":true},"drillDownPages":{}},{"id":"a597c5a3-22fa-4632-bd26-71732546f225","name":"Sites Map","x":0,"y":14,"width":12,"height":24,"definition":"sitesMap","configuration":{"pollingTime":10,"showAllLabels":false},"drillDownPages":{}},{"id":"8b133cc2-bf9a-4542-86eb-7848e058fe82","name":"Executions","x":0,"y":38,"width":8,"height":24,"definition":"executions","configuration":{"pollingTime":5,"pageSize":10,"fieldsToShow":["Blueprint","Deployment","Workflow","Created","Ended","Creator","Attributes","Actions","Status"],"showSystemExecutions":true,"sortColumn":"created_at","sortAscending":null,"singleExecutionView":false},"drillDownPages":{}},{"id":"2a2c5a53-ad5a-4300-b88a-512c9ec15718","name":"Executions Statuses Graph","x":8,"y":38,"width":4,"height":24,"definition":"executionsStatus","configuration":{"pollingTime":5},"drillDownPages":{}},{"id":"71af2c35-d2a4-4df6-b7a1-f4a3596ef7d0","name":"Button link","x":10,"y":0,"width":2,"height":8,"definition":"buttonLink","configuration":{"label":"Getting Started Walkthrough","url":"https://docs.cloudify.co/latest/trial_getting_started/examples/","fullHeight":true,"color":"#21ba45"},"drillDownPages":{}}],"isDrillDown":false},{"id":"cloudify_catalog","name":"Cloudify Catalog","description":"","tabs":[{"name":"VM Blueprint Examples","widgets":[{"id":"0c6c4713-946a-411f-bd59-e0f93d9e0bbe","name":"Blueprints Catalog","x":0,"y":0,"width":12,"height":24,"definition":"blueprintCatalog","configuration":{"pageSize":5,"jsonPath":"https://repository.cloudifysource.org/cloudify/blueprints/5.1/vm-examples.json","username":"cloudify-examples","filter":"blueprint in:name NOT local","displayStyle":"catalog","sortByName":false},"drillDownPages":{}}]},{"name":"Kubernetes Blueprint Examples","widgets":[{"id":"b685f319-5699-4703-931c-4dd964eefe70","name":"Blueprints Catalog","x":0,"y":0,"width":12,"height":24,"definition":"blueprintCatalog","configuration":{"pageSize":5,"jsonPath":"https://repository.cloudifysource.org/cloudify/blueprints/5.1/k8s-examples.json","username":"cloudify-examples","filter":"blueprint in:name NOT local","displayStyle":"catalog","sortByName":false},"drillDownPages":{}}]},{"name":"Orchestrator Blueprint Examples","widgets":[{"id":"8dc348bb-d79d-471e-9090-a8313c525ef5","name":"Blueprints Catalog","x":0,"y":0,"width":12,"height":24,"definition":"blueprintCatalog","configuration":{"pageSize":5,"jsonPath":"https://repository.cloudifysource.org/cloudify/blueprints/5.1/orc-examples.json","username":"cloudify-examples","filter":"blueprint in:name NOT local","displayStyle":"catalog","sortByName":false},"drillDownPages":{}}]}],"widgets":[{"id":"e502db00-b475-420e-b42a-e5e73db33e89","name":"Plugins Catalog","x":0,"y":24,"width":12,"height":24,"definition":"pluginsCatalog","configuration":{"jsonPath":"http://repository.cloudifysource.org/cloudify/wagons/plugins.json","sortByName":false},"drillDownPages":{}}],"isDrillDown":false},{"id":"local_blueprints","name":"Local Blueprints","description":"","tabs":[],"widgets":[{"id":"75270223-e910-4f89-9e25-1e21e79489e5","name":"Blueprints","x":0,"y":0,"width":12,"height":24,"definition":"blueprints","configuration":{"pollingTime":10,"pageSize":5,"clickToDrillDown":true,"displayStyle":"table","sortColumn":"created_at","sortAscending":null},"drillDownPages":{}},{"id":"4d984764-eb45-4520-b84a-cd3196092341","name":"Composer link","x":0,"y":25,"width":2,"height":3,"definition":"composerLink","configuration":{},"drillDownPages":{}}],"isDrillDown":false},{"id":"deployments","name":"Deployments","description":"","tabs":[],"widgets":[{"id":"3183a27d-f68f-4eb2-8494-15eac2ea7dc3","name":"Deployment Button","x":0,"y":0,"width":3,"height":3,"definition":"deploymentButton","configuration":{},"drillDownPages":{}},{"id":"154aba2f-9612-416e-b626-48a05329cc6f","name":"Filter","x":0,"y":3,"width":12,"height":3,"definition":"filter","configuration":{"pollingTime":10,"filterByBlueprints":true,"filterByDeployments":false,"filterByExecutions":false,"filterByNodes":false,"filterByNodeInstances":false,"filterByExecutionsStatus":false,"filterBySiteName":true,"allowMultipleSelection":false},"drillDownPages":{}},{"id":"2adf372f-8733-4058-bea3-02f83ea4e0e4","name":"Deployments","x":0,"y":7,"width":12,"height":40,"definition":"deployments","configuration":{"pollingTime":10,"pageSize":5,"clickToDrillDown":true,"showExecutionStatusLabel":false,"blueprintIdFilter":null,"displayStyle":"list","sortColumn":"created_at","sortAscending":null},"drillDownPages":{}}],"isDrillDown":false},{"id":"site_management","name":"Site Management","description":"","tabs":[],"widgets":[{"id":"dffe3336-7c34-44bc-b769-663dbddc670a","name":"Sites","x":0,"y":0,"width":12,"height":24,"definition":"sites","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"name","sortAscending":true},"drillDownPages":{}}],"isDrillDown":false},{"id":"tenant_management","name":"Tenant Management","description":"","tabs":[],"widgets":[{"id":"7094d5d1-951a-4878-9ac3-671769463ba4","name":"User Management","width":12,"height":20,"definition":"userManagement","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"username","sortAscending":true},"drillDownPages":{}},{"id":"4300b1af-4071-4bfd-b4c2-ea83f2539bca","name":"Tenants Management","width":12,"height":20,"definition":"tenants","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"name","sortAscending":true},"drillDownPages":{}},{"id":"3780ac98-c985-4fd3-90de-92763c4b417f","name":"User Groups Management","width":12,"height":20,"definition":"userGroups","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"name","sortAscending":true},"drillDownPages":{}}],"isDrillDown":false},{"id":"admin_operations","name":"Admin Operations","description":"","tabs":[],"widgets":[{"id":"c59359ce-1211-4965-a01c-993a412cfb39","name":"Maintenance Mode Button","x":0,"y":0,"width":3,"height":3,"definition":"maintenanceModeButton","configuration":{},"drillDownPages":{}},{"id":"16e2bade-f2e5-48fd-9fc6-a9f1ec4bc48c","name":"Cluster Status","x":0,"y":3,"width":12,"height":24,"definition":"highAvailability","configuration":{},"drillDownPages":{}},{"id":"4ce4d467-a47f-43cb-bc7a-5664d0832107","name":"Snapshots","x":0,"y":27,"width":12,"height":24,"definition":"snapshots","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"created_at","sortAscending":null},"drillDownPages":{}}],"isDrillDown":false},{"id":"system_resources","name":"System Resources","description":"","tabs":[],"widgets":[{"id":"9f4fee85-3abc-4935-b7fa-96dca35b943b","name":"Plugins","x":0,"y":0,"width":12,"height":24,"definition":"plugins","configuration":{"pollingTime":30,"pageSize":5},"drillDownPages":{}},{"id":"79131036-1749-40e5-992e-0a6b7a650957","name":"Secret Store Management","x":0,"y":24,"width":12,"height":24,"definition":"secrets","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"key","sortAscending":true},"drillDownPages":{}},{"id":"8087284f-12fb-49f4-96ec-7a0445afa789","name":"Agents Management","x":0,"y":48,"width":12,"height":24,"definition":"agents","configuration":{"pollingTime":15,"fieldsToShow":["Id","Node","Deployment","IP","Install Method","System","Version","Actions"],"installMethods":[""]},"drillDownPages":{}}],"isDrillDown":false},{"id":"logs","name":"Logs","description":"","tabs":[],"widgets":[{"id":"4431fa79-66ec-4b8a-bcc7-baaa4ec46d35","name":"Resource Filter","x":0,"y":0,"width":12,"height":3,"definition":"filter","configuration":{"pollingTime":10,"filterByBlueprints":true,"filterByDeployments":true,"filterByExecutions":true,"filterByNodes":true,"filterByNodeInstances":true,"filterByExecutionsStatus":false,"filterBySiteName":false,"allowMultipleSelection":true},"drillDownPages":{}},{"id":"254c58a3-2c3a-4516-9594-b572a9c12dc0","name":"Events/logs filter widget","x":0,"y":5,"width":12,"height":5,"definition":"eventsFilter","configuration":{},"drillDownPages":{}},{"id":"92ff0e05-498a-4a86-ae29-62ad04bc75dc","name":"Events and logs","x":0,"y":10,"width":12,"height":40,"definition":"events","configuration":{"pollingTime":2,"pageSize":15,"sortColumn":"timestamp","sortAscending":null,"fieldsToShow":["Icon","Timestamp","Blueprint","Deployment","Workflow","Operation","Node Id","Node Instance Id","Message"],"colorLogs":true,"maxMessageLength":200},"drillDownPages":{}}],"isDrillDown":false}]}	2020-09-23 10:31:36.365+00	2020-11-02 11:28:02.378+00	default_tenant
2	127.0.0.1	test	4	main	{"pages":[{"id":"dashboard","name":"Dashboard","description":"","tabs":[],"widgets":[{"id":"3b6717c6-3857-4f53-adc0-64c9f997779b","name":"Number of blueprints","x":0,"y":0,"width":2,"height":8,"definition":"blueprintNum","configuration":{"pollingTime":10,"page":"local_blueprints"},"drillDownPages":{}},{"id":"c5fe5dcb-452f-4bdc-a36a-a413e63d99e0","name":"Number of deployments","x":2,"y":12,"width":2,"height":8,"definition":"deploymentNum","configuration":{"pollingTime":10,"page":"deployments"},"drillDownPages":{}},{"id":"b6eeacf6-c515-49b0-bb8b-87d4036af558","name":"Number of plugins","x":4,"y":12,"width":2,"height":8,"definition":"pluginsNum","configuration":{"pollingTime":30,"page":"system_resources"},"drillDownPages":{}},{"id":"690f5e74-3901-4d91-86e7-14b90d59b2dd","name":"Number of compute nodes","x":6,"y":12,"width":2,"height":8,"definition":"nodesComputeNum","configuration":{"pollingTime":30},"drillDownPages":{}},{"id":"ec0ad1e3-da89-434c-bc94-81afca4496cc","name":"Number of running executions","x":8,"y":12,"width":2,"height":8,"definition":"executionNum","configuration":{"pollingTime":10},"drillDownPages":{}},{"id":"be2955e5-eb11-41f5-b2d2-d162f58a5ad9","name":"Blueprint Upload Button","x":0,"y":12,"width":2,"height":3,"definition":"blueprintUploadButton","configuration":{},"drillDownPages":{}},{"id":"752cffb6-dd65-4d81-85f9-e8de23ac418d","name":"Deployment Button","x":2,"y":20,"width":2,"height":3,"definition":"deploymentButton","configuration":{},"drillDownPages":{}},{"id":"94fcefb6-29ac-4ce7-9b8e-6afef14f3ab8","name":"Plugin Upload Button","x":4,"y":20,"width":2,"height":3,"definition":"pluginUploadButton","configuration":{},"drillDownPages":{}},{"id":"6e270b2c-c8a4-4e11-8d45-67dd081cb05f","name":"Filter","x":0,"y":28,"width":10,"height":3,"definition":"filter","configuration":{"pollingTime":10,"filterByBlueprints":true,"filterByDeployments":true,"filterByExecutions":false,"filterByNodes":false,"filterByNodeInstances":false,"filterByExecutionsStatus":true,"filterBySiteName":false,"allowMultipleSelection":true},"drillDownPages":{}},{"id":"d9f49191-b00d-48b3-89cd-cf8adf07d06e","name":"Sites Map","x":0,"y":31,"width":10,"height":24,"definition":"sitesMap","configuration":{"pollingTime":10,"showAllLabels":false},"drillDownPages":{}},{"id":"4b6f13b2-26ff-437b-9e77-102ca55fcb0c","name":"Executions","x":0,"y":55,"width":8,"height":24,"definition":"executions","configuration":{"pollingTime":5,"pageSize":10,"fieldsToShow":["Blueprint","Deployment","Workflow","Created","Ended","Creator","Attributes","Actions","Status"],"showSystemExecutions":true,"sortColumn":"created_at","sortAscending":null,"singleExecutionView":false},"drillDownPages":{}},{"id":"1b02b12f-763b-4328-a638-71a3dcba1ee3","name":"Executions Statuses Graph","x":6,"y":79,"width":4,"height":24,"definition":"executionsStatus","configuration":{"pollingTime":5},"drillDownPages":{}},{"id":"8dede102-f18e-41eb-8b2e-019f33f990b9","name":"Button link","x":8,"y":20,"width":2,"height":8,"definition":"buttonLink","configuration":{"label":"Getting Started Walkthrough","url":"https://docs.cloudify.co/latest/trial_getting_started/examples/","fullHeight":true,"color":"#21ba45"},"drillDownPages":{}},{"id":"875e977e-e19b-4e10-9a80-94df5d05b4b8","name":"Show Only My Resources","width":10,"height":4,"definition":"onlyMyResources","configuration":{},"drillDownPages":{},"x":0,"y":8}],"isDrillDown":false},{"id":"cloudify_catalog","name":"Cloudify Catalog","description":"","tabs":[{"name":"VM Blueprint Examples","widgets":[{"id":"98cf03ae-1969-40c7-a5f0-939a1a496883","name":"Blueprints Catalog","x":0,"y":0,"width":12,"height":24,"definition":"blueprintCatalog","configuration":{"pageSize":5,"jsonPath":"https://repository.cloudifysource.org/cloudify/blueprints/5.1/vm-examples.json","username":"cloudify-examples","filter":"blueprint in:name NOT local","displayStyle":"catalog","sortByName":false},"drillDownPages":{}}]},{"name":"Kubernetes Blueprint Examples","widgets":[{"id":"698e5bbc-f960-440e-aa44-6c4ddd5b8cda","name":"Blueprints Catalog","x":0,"y":0,"width":12,"height":24,"definition":"blueprintCatalog","configuration":{"pageSize":5,"jsonPath":"https://repository.cloudifysource.org/cloudify/blueprints/5.1/k8s-examples.json","username":"cloudify-examples","filter":"blueprint in:name NOT local","displayStyle":"catalog","sortByName":false},"drillDownPages":{}}]},{"name":"Orchestrator Blueprint Examples","widgets":[{"id":"606f5d42-8e06-4914-acc5-2ea666e19a45","name":"Blueprints Catalog","x":0,"y":0,"width":12,"height":24,"definition":"blueprintCatalog","configuration":{"pageSize":5,"jsonPath":"https://repository.cloudifysource.org/cloudify/blueprints/5.1/orc-examples.json","username":"cloudify-examples","filter":"blueprint in:name NOT local","displayStyle":"catalog","sortByName":false},"drillDownPages":{}}]}],"widgets":[{"id":"24e03306-708f-48c6-a11f-9bd54bf6cab3","name":"Plugins Catalog","x":0,"y":24,"width":12,"height":24,"definition":"pluginsCatalog","configuration":{"jsonPath":"http://repository.cloudifysource.org/cloudify/wagons/plugins.json","sortByName":false},"drillDownPages":{}}],"isDrillDown":false},{"id":"local_blueprints","name":"Local Blueprints","description":"","tabs":[],"widgets":[{"id":"7ecdfb4d-eb49-4ca1-bd8f-89abd04810ca","name":"Blueprints","x":0,"y":0,"width":12,"height":24,"definition":"blueprints","configuration":{"pollingTime":10,"pageSize":5,"clickToDrillDown":true,"displayStyle":"table","sortColumn":"created_at","sortAscending":null},"drillDownPages":{}},{"id":"0aa6cc66-60d3-4867-bc61-bdeb3bd69d24","name":"Composer link","x":0,"y":25,"width":2,"height":3,"definition":"composerLink","configuration":{},"drillDownPages":{}}],"isDrillDown":false},{"id":"deployments","name":"Deployments","description":"","tabs":[],"widgets":[{"id":"7b15279c-a432-4081-94c0-bb332815f704","name":"Deployment Button","x":0,"y":0,"width":3,"height":3,"definition":"deploymentButton","configuration":{},"drillDownPages":{}},{"id":"5fefd310-ad78-4914-90d5-b49c2e56c205","name":"Filter","x":0,"y":3,"width":12,"height":3,"definition":"filter","configuration":{"pollingTime":10,"filterByBlueprints":true,"filterByDeployments":false,"filterByExecutions":false,"filterByNodes":false,"filterByNodeInstances":false,"filterByExecutionsStatus":false,"filterBySiteName":true,"allowMultipleSelection":false},"drillDownPages":{}},{"id":"fe2fcdb4-47cd-40a8-9ea5-d1bc5401d746","name":"Deployments","x":0,"y":7,"width":12,"height":40,"definition":"deployments","configuration":{"pollingTime":10,"pageSize":5,"clickToDrillDown":true,"showExecutionStatusLabel":false,"blueprintIdFilter":null,"displayStyle":"list","sortColumn":"created_at","sortAscending":null},"drillDownPages":{}}],"isDrillDown":false},{"id":"site_management","name":"Site Management","description":"","tabs":[],"widgets":[{"id":"a3466ec0-05ec-4e4c-a107-b6255541f3d1","name":"Sites","x":0,"y":0,"width":12,"height":24,"definition":"sites","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"name","sortAscending":true},"drillDownPages":{}}],"isDrillDown":false},{"id":"tenant_management","name":"Tenant Management","description":"","tabs":[],"widgets":[{"id":"0e9189f1-8cc4-465b-ae97-bc6844f374dd","name":"User Management","width":12,"height":20,"definition":"userManagement","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"username","sortAscending":true},"drillDownPages":{}},{"id":"0a40035f-b88a-4a7f-b7b1-805bff7ae505","name":"Tenants Management","width":12,"height":20,"definition":"tenants","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"name","sortAscending":true},"drillDownPages":{}},{"id":"353c5823-f1d0-45ca-9b4d-7ffcb5097728","name":"User Groups Management","width":12,"height":20,"definition":"userGroups","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"name","sortAscending":true},"drillDownPages":{}}],"isDrillDown":false},{"id":"admin_operations","name":"Admin Operations","description":"","tabs":[],"widgets":[{"id":"bfaa4f36-2764-4105-b4ae-535008370ae0","name":"Maintenance Mode Button","x":0,"y":0,"width":3,"height":3,"definition":"maintenanceModeButton","configuration":{},"drillDownPages":{}},{"id":"59bddb7c-bdc6-4f1c-9834-c6bf80e697de","name":"Cluster Status","x":0,"y":3,"width":12,"height":24,"definition":"highAvailability","configuration":{},"drillDownPages":{}},{"id":"4eca10ba-2550-4967-9749-e2adf23600b6","name":"Snapshots","x":0,"y":27,"width":12,"height":24,"definition":"snapshots","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"created_at","sortAscending":null},"drillDownPages":{}}],"isDrillDown":false},{"id":"system_resources","name":"System Resources","description":"","tabs":[],"widgets":[{"id":"4d7c403d-d13b-4b84-8c77-aa3ea164cedf","name":"Plugins","x":0,"y":0,"width":12,"height":24,"definition":"plugins","configuration":{"pollingTime":30,"pageSize":5},"drillDownPages":{}},{"id":"ce254c0d-7674-45e6-ac02-0098e6d421ef","name":"Secret Store Management","x":0,"y":24,"width":12,"height":24,"definition":"secrets","configuration":{"pollingTime":30,"pageSize":5,"sortColumn":"key","sortAscending":true},"drillDownPages":{}},{"id":"d2777299-6523-465d-add7-1539bceb8a9d","name":"Agents Management","x":0,"y":48,"width":12,"height":24,"definition":"agents","configuration":{"pollingTime":15,"fieldsToShow":["Id","Node","Deployment","IP","Install Method","System","Version","Actions"],"installMethods":[""]},"drillDownPages":{}}],"isDrillDown":false},{"id":"logs","name":"Logs","description":"","tabs":[],"widgets":[{"id":"3895841e-076c-4216-b5ef-486a15eef39a","name":"Resource Filter","x":0,"y":0,"width":12,"height":3,"definition":"filter","configuration":{"pollingTime":10,"filterByBlueprints":true,"filterByDeployments":true,"filterByExecutions":true,"filterByNodes":true,"filterByNodeInstances":true,"filterByExecutionsStatus":false,"filterBySiteName":false,"allowMultipleSelection":true},"drillDownPages":{}},{"id":"19f55fc7-a391-4aef-9dc3-2ff5f8e3f05b","name":"Events/logs filter widget","x":0,"y":5,"width":12,"height":5,"definition":"eventsFilter","configuration":{},"drillDownPages":{}},{"id":"e47c5ff5-da6c-403b-802d-80604132e338","name":"Events and logs","x":0,"y":10,"width":12,"height":40,"definition":"events","configuration":{"pollingTime":2,"pageSize":15,"sortColumn":"timestamp","sortAscending":null,"fieldsToShow":["Icon","Timestamp","Blueprint","Deployment","Workflow","Operation","Node Id","Node Instance Id","Message"],"colorLogs":true,"maxMessageLength":200},"drillDownPages":{}}],"isDrillDown":false}]}	2020-10-08 15:30:48.165+00	2020-10-08 15:43:44.822+00	default_tenant
\.


--
-- Name: UserApps_id_seq; Type: SEQUENCE SET; Schema: public; Owner: cloudify
--

SELECT pg_catalog.setval('"UserApps_id_seq"', 2, true);


--
-- Data for Name: WidgetBackends; Type: TABLE DATA; Schema: public; Owner: cloudify
--

COPY "WidgetBackends" (id, "widgetId", "serviceName", method, script, "createdAt", "updatedAt") FROM stdin;
2	managers	GET_CLUSTER_STATUS	GET	{"code": "module.exports = (req, res, next, helper) => {\\n        const _ = require('lodash');\\n        const logger = helper.Logger('get_cluster_status');\\n\\n        const {\\n            query: { deploymentId },\\n            headers\\n        } = req;\\n        const extractedHeaders = {\\n            tenant: headers.tenant,\\n            'Authentication-Token': headers['authentication-token']\\n        };\\n\\n        const getClusterStatus = (ip, username, password, tenant, certificate) => {\\n            const endpointUrl = `http://${ip}/api/v3.1/cluster-status`;\\n            const endpointHeaders = {\\n                tenant,\\n                Authorization: `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`\\n            };\\n            logger.debug(`Calling: GET ${endpointUrl}`);\\n\\n            return helper.Request.doGet(\\n                `http://${ip}/api/v3.1/cluster-status`,\\n                null,\\n                true,\\n                endpointHeaders,\\n                certificate\\n            );\\n        };\\n\\n        const extractCredentials = (capabilitiesPromise, usernameSecretPromise, passwordSecretPromise) => {\\n            const ip = _.get(capabilitiesPromise, 'capabilities.endpoint');\\n            const cert = _.get(capabilitiesPromise, 'capabilities.endpoint_certificate');\\n            const username = _.get(usernameSecretPromise, 'value');\\n            const password = _.get(passwordSecretPromise, 'value');\\n            const tenant = 'default_tenant';\\n\\n            logger.debug(`Extracted data: ip=${ip}, user=${username}, cert=${cert ? 'present' : 'not present'}`);\\n            return {\\n                ip,\\n                username,\\n                password,\\n                tenant,\\n                cert\\n            };\\n        };\\n\\n        const capabilitiesPromise = helper.Manager.doGet(\\n            `/deployments/${deploymentId}/capabilities`,\\n            null,\\n            extractedHeaders\\n        ).catch(error => {\\n            logger.error(error);\\n            return Promise.reject(new Error('Cannot fetch IP address and certificate of the endpoint'));\\n        });\\n        const passwordSecretPromise = helper.Manager.doGet(\\n            '/secrets/manager_admin_password',\\n            null,\\n            extractedHeaders\\n        ).catch(() => 'admin');\\n        const usernameSecretPromise = helper.Manager.doGet(\\n            '/secrets/manager_admin_username',\\n            null,\\n            extractedHeaders\\n        ).catch(() => 'admin');\\n\\n        Promise.all([capabilitiesPromise, usernameSecretPromise, passwordSecretPromise])\\n            .then(([capabilities, usernameSecret, passwordSecret]) =>\\n                extractCredentials(capabilities, usernameSecret, passwordSecret)\\n            )\\n            .then(({ ip, username, password, tenant, cert }) => getClusterStatus(ip, username, password, tenant, cert))\\n            .then(clusterStatus => res.send(clusterStatus))\\n            .catch(error => next(error));\\n    }", "filename": "vm.js"}	2020-09-23 09:02:44.859+00	2020-11-02 11:27:31.793+00
1	executions	GET_TASKS_GRAPH	GET	{"code": "module.exports = (req, res, next, helper) => {\\n        /**\\n         * ### Due to the nature of widgetBackend, the whole logic of a function must be placed inside that function\\n         * ### and cannot be separated to several functions :(\\n         *\\n         * This method takes the 'workflow ID' and 'workflow execution name' of a specific execution\\n         * retrieves the tasks graphs associated with the execution (can be more than one) and retrieves\\n         * every task graph's operations list\\n         * In order to visually build the graph without too much headache we use elkjs for the graph\\n         * visualization calculation, elkjs receives a graph format with requirements and outputs a\\n         * graph with node and edges (x,y) coordinates to place as we please.\\n         * E.G:\\n         *\\n         * Demo of the object required by ELK to create the graph:\\n         * const graph = {\\n         *     id: \\"root\\",\\n         *     layoutOptions: {\\n         *         'elk.algorithm': 'layered',\\n         *         'elk.spacing.nodeNode': '20f',\\n         *         'layered.spacing.nodeNodeBetweenLayers': '20f'\\n         *     },\\n         *     children: [\\n         *         { id: \\"n1\\", width: 30, height: 30, labels: [{text: '1'}] },\\n         *         { id: \\"n2\\", width: 30, height: 30, labels: [{text: '2'}] },\\n         *         { id: \\"n3\\", width: 30, height: 30, labels: [{text: '3'}] },\\n         *         { id: \\"n4\\", width: 30, height: 30, labels: [{text: '4'}] },\\n         *         {\\n         *             id: \\"n5\\",\\n         *             children: [\\n         *                 { id: \\"n6\\", width: 30, height: 30, labels: [{text: '5'}] },\\n         *                 { id: \\"n7\\", width: 30, height: 30, labels: [{text: '6'}] },\\n         *                 { id: \\"n8\\", width: 30, height: 30, labels: [{text: '7'}] }\\n         *             ],\\n         *             edges: [\\n         *                 { id: \\"e6\\", sources: [ \\"n6\\" ], targets: [ \\"n7\\" ] },\\n         *                 { id: \\"e7\\", sources: [ \\"n6\\" ], targets: [ \\"n8\\" ] },\\n         *                 { id: \\"e7\\", sources: [ \\"n7\\" ], targets: [ \\"n8\\" ] }\\n         *             ],\\n         *             labels: [{text: '8 - containing graph'}]\\n         *         }\\n         *     ],\\n         *     edges: [\\n         *         { id: \\"e1\\", sources: [ \\"n1\\" ], targets: [ \\"n2\\" ] },\\n         *         { id: \\"e2\\", sources: [ \\"n1\\" ], targets: [ \\"n3\\" ] },\\n         *         { id: \\"e3\\", sources: [ \\"n1\\" ], targets: [ \\"n4\\" ] },\\n         *         { id: \\"e4\\", sources: [ \\"n2\\" ], targets: [ \\"n5\\" ] },\\n         *         { id: \\"e5\\", sources: [ \\"n2\\" ], targets: [ \\"n3\\" ] }\\n         *     ]\\n         * }\\n         * Once the object is finished creating - ELK will create the graph with the following command:\\n         * elk.layout(graph)\\n         *     .then((g) => {\\n         *         if (this.state.graphResult !== g)\\n         *         {\\n         *             this.setState({\\n         *                 graphResult: g\\n         *             })\\n         *         }\\n         *     })\\n         *     .catch(console.error)\\n         *\\n         *\\n         * More information can be found here: https://github.com/OpenKieler/elkjs\\n         */\\n        const ELK = require('elkjs');\\n        const _ = require('lodash');\\n\\n        const elk = new ELK();\\n        const logger = helper.Logger();\\n\\n        const tasksGraphsFetchUrl = '/tasks_graphs';\\n        const operationsFetchUrl = '/operations';\\n\\n        const localWorkflowTask = 'LocalWorkflowTask';\\n        const nopLocalWorkflowTask = 'NOPLocalWorkflowTask';\\n        const subgraphTask = 'SubgraphTask';\\n\\n        // ELK Tasks graph skeleton\\n        const tasksGraph = {\\n            id: 'tasksGraph',\\n            layoutOptions: {\\n                'elk.algorithm': 'layered',\\n                'elk.spacing.nodeNode': '30f', // Vertical spacing between nodes in each layer\\n                'layered.spacing.nodeNodeBetweenLayers': '50f', // Horizontal spacing between layers\\n                hierarchyHandling: 'INCLUDE_CHILDREN' // To ensure inner nodes can have proper edges to nodes with different parents\\n            },\\n            children: [],\\n            edges: []\\n        };\\n        const paddingLeftRight = 24;\\n        const paddingTop = 46;\\n        const paddingBottom = 28;\\n        const subGraphLayoutOptions = {\\n            'elk.padding': `[top=${paddingTop},left=${paddingLeftRight},bottom=${paddingBottom},right=${paddingLeftRight}]`\\n        };\\n\\n        // This is a rough estimate of how much space each character in a string takes.\\n        // This will be used when a text needs to be displayed inside a node (rectangle)\\n        // and exceeds its width, resulting in increasing the rectangle's height and\\n        // breaking the string into 2 (and so forth...)\\n        const textSizingFactor = 5.8;\\n        const textHeight = 18;\\n\\n        const runGraphCreation = () => {\\n            const tasksGraphParams = { ...req.query };\\n            const headers = _.pick(req.headers, 'authentication-token', 'tenant');\\n\\n            const operationsList = [];\\n            helper.Manager.doGet(tasksGraphsFetchUrl, tasksGraphParams, headers)\\n                .then(data => {\\n                    const { items } = data;\\n\\n                    if (_.isEmpty(items)) {\\n                        const message = `No tasks graph for execution id=${tasksGraphParams.execution_id}.`;\\n                        logger.info(message);\\n                        res.status(404).send({ message });\\n                        return;\\n                    }\\n\\n                    const operationsPromises = _.map(items, graph =>\\n                        helper.Manager.doGet(operationsFetchUrl, { graph_id: graph.id }, headers)\\n                    );\\n\\n                    Promise.all(operationsPromises)\\n                        .then(results => {\\n                            _.map(results[0].items, item => {\\n                                operationsList.push(item);\\n                            });\\n                            return operationsList;\\n                        })\\n                        .then(operationsList => {\\n                            // Constructing SubGraphs\\n                            let allSubgraphs = constructSubgraphs(operationsList);\\n                            // Constructing Dependencies\\n                            allSubgraphs = constructDependencies(operationsList, allSubgraphs);\\n                            // Increase the Node's rectangle height based on inner texts\\n                            allSubgraphs = adjustingNodeSizes(allSubgraphs);\\n                            // Remove LocalWorkflow & NOPWorkflowTasks from the graph while keeping it connected\\n                            allSubgraphs = cleanSubgraphsList(allSubgraphs);\\n                            // Creating the ELK-formatted graph\\n                            return createELKTasksGraphs(allSubgraphs);\\n                        })\\n                        .then(tasksGraph => {\\n                            elk.layout(tasksGraph).then(elkGraph => {\\n                                res.send(elkGraph);\\n                            });\\n                        })\\n                        .catch(error => {\\n                            logger.error(error);\\n                            next(error);\\n                        });\\n                })\\n                .catch(error => {\\n                    logger.error(error);\\n                    next(error);\\n                });\\n        };\\n        const constructSubgraphs = operationsList => {\\n            // All the subgraphs and leaves are in the same list for better time-complexity performance, meaning -\\n            // For every subgraph - instead of traversing its children until we find the desired subgraph/leaf, we simply\\n            // keep the child (or grand child) subgraph/leaf in the first-tier list as a pointer to the real child.\\n            // When we're done creating the skeleton for ELK, we remove all the pointers and only keep the root subgraphs.\\n            const allSubgraphs = {};\\n            _.map(operationsList, task => {\\n                let taskName = _.split(task.name, 'cloudify.interfaces.');\\n                taskName = taskName.length > 1 ? taskName[1] : _.upperFirst(taskName[0]);\\n\\n                let taskOperation = '';\\n                const taskArgs = task.parameters.task_kwargs;\\n                if (taskArgs.cloudify_context && taskArgs.cloudify_context.operation) {\\n                    taskOperation = taskArgs.cloudify_context.operation.name;\\n                    taskOperation = _.split(taskOperation, 'cloudify.interfaces.');\\n                    taskOperation = taskOperation.length > 1 ? taskOperation[1] : taskOperation[0];\\n                    taskOperation = _.capitalize(_.lowerCase(taskOperation));\\n                }\\n\\n                const cloudifyContext = _.get(taskArgs.kwargs, '__cloudify_context', {});\\n                let subGraph = {\\n                    // subGraph can be a subGraph or a 'leaf'\\n                    id: task.id,\\n                    labels: [\\n                        {\\n                            text: taskName,\\n                            retry: 0,\\n                            type: task.type,\\n                            state: _.upperFirst(task.state),\\n                            operation: taskOperation,\\n                            display_text: ''\\n                        }\\n                    ],\\n                    nodeInstanceId: cloudifyContext.node_id,\\n                    operation: _.get(cloudifyContext.operation, 'name'),\\n                    children: [],\\n                    edges: [],\\n                    containing_subgraph: null // Needed to distinguish which nodes to keep (=not null -> not root-level subgraphs -> will be removed)\\n                };\\n                if (!allSubgraphs.hasOwnProperty(task.id)) {\\n                    allSubgraphs[task.id] = subGraph;\\n                } else {\\n                    allSubgraphs[task.id].labels[0].text = taskName;\\n                    allSubgraphs[task.id].labels[0].type = task.type;\\n                    allSubgraphs[task.id].labels[0].operation = taskOperation;\\n                    subGraph = allSubgraphs[task.id];\\n                }\\n                if (task.parameters.containing_subgraph) {\\n                    // Task is inside a Subgraph (could be subgraph in subgraph)\\n                    // Need to create its parent and update self as its child\\n                    const { containing_subgraph } = task.parameters;\\n                    subGraph.containing_subgraph = containing_subgraph;\\n                    if (!allSubgraphs.hasOwnProperty(containing_subgraph)) {\\n                        // Parent does not exist - creating parent skeleton to be filled later\\n                        const parentGraph = {\\n                            id: containing_subgraph,\\n                            labels: [{ state: null }],\\n                            children: [subGraph],\\n                            edges: [],\\n                            containing_subgraph: null\\n                        };\\n                        allSubgraphs[containing_subgraph] = parentGraph;\\n                    } else {\\n                        // parentGraph already exists - only update its children and its child that its contained in it\\n                        allSubgraphs[containing_subgraph].children.push(subGraph);\\n                        allSubgraphs[containing_subgraph].labels[0].state = null;\\n                        allSubgraphs[task.id].containing_subgraph = containing_subgraph;\\n                    }\\n                }\\n            });\\n            return allSubgraphs;\\n        };\\n        const constructDependencies = (operationsList, allSubgraphs) => {\\n            // Connecting all the operations into a graph\\n            // *IMPORTANT NOTE* - Retrying tasks depend on their previous failed task\\n            allSubgraphs.edges = [];\\n            _.map(operationsList, task => {\\n                if (task.parameters.current_retries > 0) {\\n                    allSubgraphs[task.id].labels[0].retry = task.parameters.current_retries;\\n                }\\n                if (allSubgraphs[task.id].containing_subgraph) {\\n                    allSubgraphs[task.id].width = 270;\\n                    allSubgraphs[task.id].height = 40;\\n                }\\n                _.map(operationsList, dependantTask => {\\n                    const edge = {\\n                        id: '',\\n                        sources: [],\\n                        targets: []\\n                    };\\n                    if (\\n                        dependantTask.dependencies.indexOf(task.id) > -1 ||\\n                        dependantTask.parameters.retried_task === task.id\\n                    ) {\\n                        edge.id = `${task.id}_${dependantTask.id}`;\\n                        edge.sources.push(task.id);\\n                        edge.targets.push(dependantTask.id);\\n                        const { containing_subgraph } = allSubgraphs[task.id];\\n                        if (containing_subgraph === null) {\\n                            allSubgraphs.edges.push(edge);\\n                        } else {\\n                            allSubgraphs[containing_subgraph].edges.push(edge);\\n                        }\\n                    }\\n                });\\n            });\\n            return allSubgraphs;\\n        };\\n        const safeDeleteIrrelevantGraphVertices = allSubgraphs => {\\n            // Remove LocalWorkflow, NOPWorkflowTasks and retrying-tasks from the graph\\n            // while keeping it connected\\n            const existingEdges = new Set(); // Used to remove duplicate edges\\n            _.map(allSubgraphs, subGraph => {\\n                if (subGraph.children && subGraph.children.length > 0) {\\n                    // Go through all the subgraphs\\n                    subGraph.children = _.map(subGraph.children, workflowTask => {\\n                        // For each subgraph, go through all the tasks\\n                        if (\\n                            workflowTask.labels[0].type === localWorkflowTask ||\\n                            workflowTask.labels[0].type === nopLocalWorkflowTask ||\\n                            workflowTask.labels[0].retry > 0\\n                        ) {\\n                            // Remove all LocalWorkflowTasks and NOPWorkflowTasks from the subgraph\\n                            // Connect its 'target' edges to it's parents' 'target' edges\\n                            // Remove the node when done\\n                            const sourceNodes = [];\\n                            const targetNodes = [];\\n                            // Need to go through the array twice because the\\n                            // update of the rest of the edges must be after all the\\n                            // \\"Node to remove\\"'s edges have been scanned\\n                            subGraph.edges = _.map(subGraph.edges, edge => {\\n                                const sourceNode = edge.sources[0];\\n                                const targetNode = edge.targets[0];\\n                                if (sourceNode === workflowTask.id) {\\n                                    targetNodes.push(targetNode);\\n                                } else if (targetNode === workflowTask.id) {\\n                                    sourceNodes.push(sourceNode);\\n                                    if (workflowTask.labels[0].retry > 0) {\\n                                        // If a task is retrying - delete it and combine it with its father\\n                                        allSubgraphs[sourceNode].labels[0].retry = workflowTask.labels[0].retry;\\n                                        allSubgraphs[sourceNode].labels[0].state = workflowTask.labels[0].state;\\n                                        allSubgraphs[sourceNode].labels[0].display_text =\\n                                            workflowTask.labels[0].display_text;\\n                                    }\\n                                } else {\\n                                    return edge;\\n                                }\\n                            }).filter(edge => edge !== undefined);\\n                            _.map(sourceNodes, sourceNodeId => {\\n                                _.map(targetNodes, targetNodeId => {\\n                                    const newEdge = {\\n                                        id: `${sourceNodeId}_${targetNodeId}`,\\n                                        sources: [`${sourceNodeId}`],\\n                                        targets: [`${targetNodeId}`]\\n                                    };\\n                                    if (!existingEdges.has(newEdge.id)) {\\n                                        subGraph.edges.push(newEdge);\\n                                        existingEdges.add(newEdge.id);\\n                                    }\\n                                });\\n                            });\\n                        } else {\\n                            return workflowTask;\\n                        }\\n                    }).filter(workflowTask => workflowTask !== undefined);\\n                }\\n            });\\n            return allSubgraphs;\\n        };\\n        const adjustingNodeSizes = allSubgraphs => {\\n            // Since some operations' inner text may exceed its Node's width\\n            // we need to increase the Node's height accordingly and split the text\\n            // This process must be here after all the nodes are in the list\\n            const textSplitCalculation = (nodeWidth, textToCalculate) => {\\n                const maximumLength = _.floor((nodeWidth - paddingLeftRight * 2) / textSizingFactor) - 2;\\n                if (textToCalculate.length > maximumLength) {\\n                    let indexOfSplitLocation;\\n                    // Traversing the splitting location backwards to find the beginning of the word\\n                    for (indexOfSplitLocation = maximumLength; indexOfSplitLocation >= 0; indexOfSplitLocation--) {\\n                        if (textToCalculate[indexOfSplitLocation] === ' ') {\\n                            break;\\n                        }\\n                    }\\n                    const textArr = textSplitCalculation(\\n                        nodeWidth,\\n                        textToCalculate.substring(indexOfSplitLocation + 1)\\n                    );\\n                    textArr.unshift(textToCalculate.substring(0, indexOfSplitLocation + 1));\\n                    return textArr;\\n                }\\n                return [textToCalculate];\\n            };\\n            _.map(allSubgraphs, subGraph => {\\n                if (subGraph.containing_subgraph !== null && subGraph.labels) {\\n                    subGraph.labels[0].text = _.capitalize(_.lowerCase(subGraph.labels[0].text));\\n                }\\n                if (subGraph.children && subGraph.children.length !== 0) {\\n                    subGraph.layoutOptions = subGraphLayoutOptions;\\n                }\\n                if (subGraph.children && subGraph.children.length === 0) {\\n                    // if leaf and not the 'edges' object\\n                    const labels = subGraph.labels[0];\\n                    let numberOfSplits = 0;\\n                    let textToCalculate = '';\\n                    if (labels.text) {\\n                        textToCalculate = labels.text;\\n                        textToCalculate = textSplitCalculation(subGraph.width, textToCalculate);\\n                        // Each element in the resulting array will be rendered in a separate <text> element\\n                        labels.display_title = textToCalculate;\\n                        numberOfSplits += textToCalculate.length - 1;\\n                    }\\n                    // Description text\\n                    const tempArr = [];\\n                    if (labels.operation) {\\n                        tempArr.push(labels.operation);\\n                    }\\n                    const { state } = labels;\\n                    if (state) {\\n                        const retriesCount = labels.retry;\\n                        tempArr.push(state === 'Pending' && retriesCount ? `Pending retry (${retriesCount})` : state);\\n                    }\\n                    textToCalculate = tempArr.join(' - ');\\n                    textToCalculate = textSplitCalculation(subGraph.width, textToCalculate);\\n                    // Each element in the resulting array will be rendered in a separate <text> element\\n                    labels.display_text = textToCalculate;\\n                    numberOfSplits += textToCalculate.length - 1;\\n                    if (numberOfSplits > 0) {\\n                        subGraph.height += textHeight * numberOfSplits;\\n                    }\\n                    subGraph.height += 10;\\n                }\\n            });\\n            return allSubgraphs;\\n        };\\n        const cleanSubgraphsList = allSubgraphs => {\\n            // Removing irrelevant vertices (when a task is rescheduled due to failure mostly)\\n            allSubgraphs = safeDeleteIrrelevantGraphVertices(allSubgraphs);\\n            // Removing subgraphs with 0 children\\n            allSubgraphs = _.omitBy(allSubgraphs, subGraph => {\\n                if (\\n                    _.isEmpty(subGraph.children) &&\\n                    !_.isEmpty(subGraph.labels) &&\\n                    subGraph.labels[0].type === subgraphTask\\n                ) {\\n                    // Verify the subGraph doesn't have connected edges\\n                    if (subGraph.containing_subgraph !== null) {\\n                        let i = allSubgraphs[subGraph.containing_subgraph].edges.length;\\n                        while (i--) {\\n                            if (\\n                                allSubgraphs[subGraph.containing_subgraph].edges[i].sources.indexOf(subGraph.id) > -1 ||\\n                                allSubgraphs[subGraph.containing_subgraph].edges[i].targets.indexOf(subGraph.id) > -1\\n                            ) {\\n                                allSubgraphs[subGraph.containing_subgraph].edges.splice(i, 1);\\n                            }\\n                        }\\n                    } else {\\n                        let i = allSubgraphs.edges.length;\\n                        while (i--) {\\n                            if (\\n                                allSubgraphs.edges[i].sources.indexOf(subGraph.id) > -1 ||\\n                                allSubgraphs.edges[i].targets.indexOf(subGraph.id) > -1\\n                            ) {\\n                                allSubgraphs.edges.splice(i, 1);\\n                            }\\n                        }\\n                    }\\n                    return true;\\n                }\\n            });\\n            allSubgraphs = _.omitBy(allSubgraphs, subGraph => {\\n                // Return all the nodes that are root-level subgraphs\\n                const { containing_subgraph } = subGraph;\\n                delete subGraph.containing_subgraph;\\n                return containing_subgraph;\\n            });\\n            return allSubgraphs;\\n        };\\n        const createELKTasksGraphs = allSubgraphs => {\\n            tasksGraph.edges = allSubgraphs.edges;\\n            allSubgraphs = _.omit(allSubgraphs, ['edges']);\\n            _.map(allSubgraphs, subGraph => {\\n                tasksGraph.children.push(subGraph);\\n            });\\n            return tasksGraph;\\n        };\\n\\n        runGraphCreation();\\n    }", "filename": "vm.js"}	2020-09-23 09:02:44.849+00	2020-11-02 11:27:31.794+00
3	managers	GET_SPIRE_DEPLOYMENTS	GET	{"code": "module.exports = (req, res, next, helper) => {\\n        const _ = require('lodash');\\n        // const logger = helper.Logger('get_spire_deployments');\\n\\n        const { headers } = req;\\n        const extractedHeaders = {\\n            tenant: headers.tenant,\\n            'Authentication-Token': headers['authentication-token']\\n        };\\n        let spireDeployments = [];\\n\\n        return helper.Manager.doGetFull(\\n            '/deployments',\\n            {\\n                _include: 'id,workflows,capabilities,description',\\n                description:\\n                    'This blueprint creates several VMs, installs a Cloudify Manager on each of them, ' +\\n                    'creates a Cloudify Spire Management Cluster between all the managers and uploads ' +\\n                    'several auxiliary resources to the cluster.\\\\n'\\n            },\\n            extractedHeaders\\n        )\\n            .then(data => {\\n                spireDeployments = data.items;\\n                const capabilitiesPromises = _.map(spireDeployments, deployment =>\\n                    helper.Manager.doGet(`/deployments/${deployment.id}/capabilities`, null, extractedHeaders)\\n                );\\n\\n                const executionsPromise = helper.Manager.doGet(\\n                    '/executions',\\n                    {\\n                        _sort: '-ended_at',\\n                        deployment_id: _.map(spireDeployments, deployment => deployment.id)\\n                    },\\n                    extractedHeaders\\n                );\\n\\n                return Promise.all([executionsPromise, ...capabilitiesPromises]);\\n            })\\n            .then(([executions, ...spireDeploymentsCapabilities]) => {\\n                const executionsData = _.groupBy(executions.items, 'deployment_id');\\n\\n                return Promise.resolve({\\n                    items: _.sortBy(\\n                        _.map(spireDeploymentsCapabilities, deploymentCapabilities => {\\n                            const spireDeploymentId = deploymentCapabilities.deployment_id;\\n                            const spireEndpointIp = _.get(deploymentCapabilities.capabilities, 'endpoint', '');\\n                            const deployment = _.find(\\n                                spireDeployments,\\n                                d => d.id === deploymentCapabilities.deployment_id\\n                            );\\n                            const workflows = _.get(deployment, 'workflows', []);\\n\\n                            return {\\n                                id: spireDeploymentId,\\n                                ip: spireEndpointIp,\\n                                workflows,\\n                                lastExecution: _.first(executionsData[spireDeploymentId])\\n                            };\\n                        }),\\n                        'id'\\n                    ),\\n                    total: _.size(spireDeploymentsCapabilities)\\n                });\\n            })\\n            .then(data => res.send(data))\\n            .catch(error => next(error));\\n    }", "filename": "vm.js"}	2020-09-23 09:02:44.858+00	2020-11-02 11:27:31.809+00
\.


--
-- Name: WidgetBackends_id_seq; Type: SEQUENCE SET; Schema: public; Owner: cloudify
--

SELECT pg_catalog.setval('"WidgetBackends_id_seq"', 3, true);


--
-- PostgreSQL database dump complete
--

