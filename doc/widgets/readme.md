# How to write a widget

Cloudify UI provides an easy way to add widgets to the system.

## Widget file structure

A widget consists of several files. 2 are mandatory.

* widget.js - Holds the widget's definition - mandatory.
* widget.png - A preview image of the widget - mandatory.
* widget.html - A widget template file. This is used only if you want to write a widget without using react (using vaniala js with html template). The template file is optional.
* widget.css - A css file that the widget uses. This file is optional.

A widget should be placed in the widgets library, in a library carrying the id of the widget.

For example, if we are creating a blueprint widget (id=blueprint) then the blueprint library should be:

```
   /widgets
      /blueprint
         widget.js
         widget.html
         widget.png
         widget.css
```

We have 2 ways of writing widgets. The first one is using vanila JS. In this approach we allow attaching an html template file and we support some callbacks that we will described later.
The second and recommended way is to use React. Since react requires build, you can either build the widget.js file yourself, or use our build system for this.
To use our build system you will have to put your widget.js file into an 'src' library along with any other files that you may require.
In the widget.js file you can use 'import' for the other files and split your widget to several file. You can also use any ES6 features.

In this approach the filesystem will look like so:

```
   /widgets
      /blueprint
         /src
            widget.js
         widget.js - will be generated by the build system
         widget.html
         widget.png
         widget.css
```



## Widget definition

Each widget.js file should have one call to a global function called 'Stage.defineWidget'.


###Stage.defineWidget gets a settings object with the following options:

option | type | default | description
--- | --- | --- | ---
id |  String | - |  *Required* The id of the widget definition. Should match the directory that we placed this widget in
name | String | - |  *Required* The display name of this wudget. This name will show in the 'add Widget' dialog, and will also be the default widget name once added to the page.
description | String | - | An optional description of the widget. It will be shown in the 'add Widget' dialog below the widget name.
initialWidth | Integer| - | *Required* The default (initial) width of the widget when added to a page
initialHeight | Integer| - | *Required* The default (initial) height of the widget when added to a page
color | String | red | one out of : red , orange , yellow, olive, green, teal,blue, violet,purple,pink,brown,grey,black
showHeader | Boolean| true | If we should show a widget header or not. If an header is not shown the user cannot change the widget name (which is only visible in the header) 
isReact | Boolean| false | You should set this to true to write a React widget
fetchUrl | String or Object | - | If fetchUrl exists, the data from this url will be fetched by the application and passed to the render and postRender methods. If you want to fetch multiple urls, you need to pass an object where the key is a name you pick for this data, and value is the url. *Important* the render will be called once before the data is fetched (to allow showing loading or partial data) and once the data is fetched.
initialConfiguration | Array | - | A list of widget configuration options. These options will appear when clicking 'configure' icon on the widget in edit mode. It can also be accessed in the widget to determine the current selected configuration.
pageSize | Integer | - | The initial page size for widgets that supports pagination


###Available widget functions

*init*()
Init is called when the widget definition is loaded, which happens once when the system is loaded. This can be used to define some global stuff, such as classes and objects we are going to use in our widget definition.

*render*(widget,data,toolbox)
Render is called each time the widget needs to draw itself.
It can be when the page is loaded, when widget data was changed, when context data was changed , when widget data was fetched, and etc.


render parameters are:
 
* The widget object itself (see description in 'Widget object' section)
* The fetched data (either using fetchUrl or fetchData method). The data will be null if fetchData or fetchUrl was not defined, and also until the data is fetched it will pass null to the render method (if you expect data you can render 'loading' indication in such a case)
* The toolbox object (see description in the 'Toolbox object' section)

*postRender*(el,widget,data,toolbox)
*fetchData*(widget,toolbox, fetchParams)

###Widget object

Event object has the following attributes

attribute | description
--- | ---
id | The id of the widget (uuid)
name | The display name of the widget (The widget definition name is the default name for the widget, but the user can change it)
height | The actual height of the widget on the page
width | The actual width of the widget on the page 
x | The actual x location of the widget on the page
y | The actual y location of the widget on the page
definition | The widget definition object as it was passed to defineWidget method. The only additional field there that the widget can access is the 'template'. The template is fetched from the html and added on the widget definition.

###Toolbox object
The toolbox object gives the widget tools to communicate with the application and with other widgets. It also gives some generic tools that the widget might require.

The toolbox gives access to the following tools:

*getEventBus*() - used to listen (register) to events and trigger events.
The event bus is used for a widget to broadcast an event (usually a change it made that will effect others). For example, if a blueprints widget creates a new deployment it needs to let all the other widgets know that the deployment list was changed. The listening widgets will then call 'refresh'
Event buss supports the following methods:

*on (event, callback, context)

*trigger (event

*off(event,offCallback)

for example:

```javascript
    componentDidMount() {
        this.props.toolbox.getEventBus().on('deployments:refresh',this._refreshData,this);
    }

    componentWillUnmount() {
        this.props.toolbox.getEventBus().off('deployments:refresh',this._refreshData);
    }

    _deleteDeployment() {
        ...
        actions.doDelete(deploymentToDelete).then(()=>{
            ...
            this.props.toolbox.getEventBus().trigger('deployments:refresh');
        }).catch((err)=>{
            ...
        });
    }

```

*getManager*() - used to access the connected manager

The manager gives access to the manager's rest api. The url is the service url without the /api/vX.X

    doGet(url,params)

    doPost(url,params,data)

    doDelete(url,params,data)

    doPut(url,params,data)

    doUpload(url,params,file,method)

It also exposes a method to only construcgt the URL. It should be used carefully since some request headers needs to be passed to the manager.

    getManagerUrl(url,data)


for example:

```javascript
    return this.toolbox.getManager().doDelete(`/deployments/${blueprint.id}`);


    doUpload(blueprintName,blueprintFileName,file) {
        return this.toolbox.getManager().doUpload(`/blueprints/${blueprintName}`,_.isEmpty(blueprintFileName) ? null : {
            application_file_name: blueprintFileName+'.yaml'
        },file);
    }

```


*getContext*() - used to access the application context
A widget context gives access to the application context. Using the context we can pass arguments between widgets, for example when a blueprint is selected, set the context to the selected blueprint, and all the widgets that can filter by blueprint can read this value and filter accordingly.
The context supports these methods:

 * setValue(key,value)
 * getValue(key) - returns value


It also supports the following functions:

*refresh*()

If we did some actions in the widget that will require fetching the data again (for example we added a record) we can ask the app to refresh only this widget by calling refresh()

*drillDown*(widget,defaultTemplate,drilldownContext)

Drilling down to a page requires passing the drilldown page template name. Templates will be described in the next section. When a widget is on a page, and drilldown action done (through link click event to a button for example), if its the first time we access this drilldown page, the app will create a new page based on the passed template. Once this page is created the user can edit it like any other page. All next accesses to this page will use this page.
Also you can pass a 'drilldownContext' to the drilldown page. This context will be saved on the URL and will be available through the app context. This value will be saved upon refresh, so if a user drilldown to a page, and then refreshes the page, the context will be saved (for example - selected deployment in drilldown deployment page)

for example:
When selecting a deployment we drilldown to a deployment page. It looks like this:

```javascript
    _selectDeployment(item) {
        this.props.toolbox.drillDown(this.props.widget,'deployment',{deploymentId: item.id});
    }
```

The 'deployment' template looks like this:
```json
{
  "name": "Deployment",
  "widgets": [
    {
      "name": "topology",
      "widget": "topology",
      "width": 12,
      "height": 5,
      "x": 0,
      "y": 0
    },
    {
      "name": "CPU Utilization - System",
      "width": 6,
      "height": 4,
      "widget": "cpuUtilizationSystem",
      "x": 0,
      "y": 5
    },
    {
      "name": "CPU Utilization - User",
      "width": 6,
      "height": 4,
      "widget": "cpuUtilizationUser",
      "x": 6,
      "y": 5
    },
    {
      "name": "Deployment Inputs",
      "width": 5,
      "height": 3,
      "widget": "inputs",
      "x": 0,
      "y": 9
    },
    {
      "name": "Deployment Events",
      "width": 7,
      "height": 3,
      "widget": "events",
      "x": 5,
      "y": 9
    }
  ]
}
```

###Drilldown page templates
Drill down page templates are defined in the '/templates' library.

The library looks liks this:
```
   /templates
      template1.json
      template2.json
      ...
      templates.json     
```

The templates.json contains a list of the available templates (temporary until we'll have a server that will handle this).
Each template file contains one page template configuration.

template configuration has a name which is the default page name, and list of widgets. 
Each widget will have the following fields

field | description
--- | ---
name | Widget default name
widget | The id of the widget to use
width | The initial width of the widget on the page
height | The initial height of the widget on the page
x | The initial x location of the widget on the page
y | The initial y location of the widget on the page

If x and/or y are not defined the page will be auto arranged (not recommended)

For example:
```json
{
  "name": "template-name",
  "widgets": [
    {
      "name": "topology",
      "widget": "topology",
      "width": 12,
      "height": 5,
      "x": 0,
      "y": 0
    },
    ....
  ]
}
```

### Additional libraries that are available to a widget

*moment* a date/time parsing utility. [Moment documentation](http://momentjs.com/docs/)

for example:
```javascript

        var formattedData = Object.assign({},data,{
            items: _.map (data.items,(item)=>{
                return Object.assign({},item,{
                    created_at: moment(item.created_at,'YYYY-MM-DD HH:mm:ss.SSSSS').format('DD-MM-YYYY HH:mm'),
                    updated_at: moment(item.updated_at,'YYYY-MM-DD HH:mm:ss.SSSSS').format('DD-MM-YYYY HH:mm'),
                })
            })
        });
```

*jQuery*

for example:
```
    postRender: function(el,widget,data,toolbox) {
        $(el).find('.ui.dropdown').dropdown({
            onChange: (value, text, $choice) => {
                context.setValue('selectedValue',value);
            }
        });
    })
```

*Lodash*

for example:
```
    _.each(items, (item)=>{
        ...
    });
```

## Widget template

The widget template is an html file written with [lodash template engine](https://lodash.com/docs/4.15.0#template).
 
Widget template if fetched when the widget definition is loaded, and its passed to the render function. To access it use widget.definition.template.
To render the template using the built in lodash templates engine use `_.template(widget.definition.template)(data);`, where 'data' is any context you want to pass on to the template.
For example, a simple render function will look like this

```javascript
    render: function(widget,data,toolbox) {
        if (!widget.definition.template) {
            return 'missing template';
        }
        return _.template(widget.definition.template)();
    }
```
## Links

* [Components documentation](../components/readme.md)